<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025æ¡Œæ¬¡åœ°åœ–æŸ¥è©¢</title>
    <style>
        :root { 
            --hud-bg: rgba(10, 15, 30, 0.95); 
            --neon-blue: #00f7ff; 
            --neon-purple: #bc13fe;
            --neon-gold: #ffaa00;
        }
        body, html { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #020205; color: #fff; }
        
        #three-canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        
        #ui-layer {
            position: absolute; top: 30px; left: 30px; z-index: 10;
            width: 360px; pointer-events: none;
        }
        
        .hud-panel {
            background: var(--hud-bg);
            border: 1px solid rgba(255,255,255,0.1);
            border-top: 4px solid var(--neon-blue);
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        
        .hud-title {
            margin: 0 0 20px 0; font-size: 1.2rem; letter-spacing: 3px; font-weight: 800;
            color: #fff; text-transform: uppercase;
            display: flex; align-items: center; justify-content: space-between;
        }
        .hud-title::after { content: ''; display: block; width: 10px; height: 10px; background: var(--neon-blue); border-radius: 50%; box-shadow: 0 0 10px var(--neon-blue); }

        .input-wrapper { position: relative; margin-bottom: 20px; }
        
        input {
            width: 100%; background: #1a1f2e; border: 1px solid #333;
            color: #fff; padding: 15px; font-size: 1rem; outline: none; transition: 0.3s;
            box-sizing: border-box; border-radius: 4px;
        }
        input:focus { border-color: var(--neon-blue); background: #23293d; }

        button {
            position: absolute; right: 5px; top: 5px; bottom: 5px;
            background: var(--neon-blue); color: #000; border: none;
            padding: 0 20px; font-weight: bold; cursor: pointer; transition: 0.3s;
            border-radius: 3px;
        }
        button:hover { background: #fff; }

        .result-card {
            margin-top: 15px; padding: 15px; background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid var(--neon-gold); border-radius: 0 4px 4px 0;
        }
        .info-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; color: #ccc; }
        .info-val { color: #fff; font-weight: 600; }
        .big-seat-num { font-size: 2.2rem; color: var(--neon-gold); font-weight: 800; }
        
        /* è¼‰å…¥å…‰æ¢ */
        .loader-bar { height: 2px; width: 0%; background: var(--neon-blue); transition: width 0.3s; position: absolute; bottom: 0; left: 0; }
    </style>
</head>
<body>

    <div id="three-canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <h2 class="hud-title">SEAT NAV OS</h2>
            <div class="input-wrapper">
                <input type="text" id="employeeName" placeholder="è¼¸å…¥å§“åæŸ¥è©¢..." onkeydown="if(event.key==='Enter') queryDeskLocation()">
                <button onclick="queryDeskLocation()">SEARCH</button>
                <div class="loader-bar" id="loader"></div>
            </div>
            <div id="status-msg" style="font-size: 0.85rem; color: #666;">SYSTEM READY</div>
            <div id="result-area" style="display: none;"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script>
        // ğŸš¨ è«‹ç¢ºèªæ‚¨çš„ GAS URL
        const GAS_API_URL = 'https://script.google.com/macros/s/AKfycbxQuKFadSahEF-BeKW1LVtHIMBLwPpK7RevNTMtnLHpFgT4a-L60O8j1fFCg98NHb4/exec';

        let scene, camera, renderer, controls;
        let tableGroups = {}; 
        
        // --- ä½ˆå±€åƒæ•¸ ---
        const COLS_PER_SIDE = 7; 
        const ROWS_BOTTOM = 8;   
        const ROWS_TOP = 9;      
        const TOTAL_ROWS = 17; 
        const TOTAL_COLS = 14;      

        const SPACING_X = 5.5;  
        const SPACING_Z = 5.5;  
        const AISLE_GAP_X = 6;  
        const AISLE_GAP_Z = 6;  

        // è¦–è¦ºå‡ç´šåƒæ•¸
        const TABLE_RADIUS = 1.6;
        const INNER_TABLE_RADIUS = 0.8; // è½‰ç›¤åŠå¾‘

        window.onload = init;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.Fog(0x020205, 50, 250);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 110, 100); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // é–‹å•Ÿé™°å½±
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('three-canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;

            // ç‡ˆå…‰ç³»çµ±
            const ambient = new THREE.AmbientLight(0x333333);
            scene.add(ambient);

            // ä¸»å…‰æº (ç”¢ç”Ÿé™°å½±)
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // è£é£¾å…‰ (å¢åŠ è³ªæ„Ÿ)
            const spotLight = new THREE.SpotLight(0x00f7ff, 0.5);
            spotLight.position.set(0, 100, 0);
            spotLight.angle = Math.PI / 4;
            scene.add(spotLight);
            
            // åœ°æ¿
            const grid = new THREE.GridHelper(300, 60, 0x333333, 0x111111);
            scene.add(grid);

            // ç”Ÿæˆä½ˆå±€
            generateLayout();

            window.addEventListener('resize', onResize);
            animate();
        }

        // --- æ ¸å¿ƒä½ˆå±€é‚è¼¯ (åŒ…å«è·³è™Ÿæ©Ÿåˆ¶) ---
        function generateLayout() {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                
                let tableCounter = 1; // ç•¶å‰çš„æ¡Œè™Ÿ
                let positionCounter = 1; // ç•¶å‰çš„ã€Œä½ç½®ã€åºè™Ÿ (ç”¨ä¾†åˆ¤æ–·ç¬¬222å€‹ä½ç½®)

                // é€è¡Œç”Ÿæˆ
                for (let c = 0; c < TOTAL_COLS; c++) {
                    
                    const isGoingUp = (c % 2 === 0);
                    let columnPositions = [];

                    for (let r = 0; r < TOTAL_ROWS; r++) {
                        // è¨ˆç®— X
                        let xPos = (c - (TOTAL_COLS / 2) + 0.5) * SPACING_X;
                        if (c >= COLS_PER_SIDE) xPos += AISLE_GAP_X / 2;
                        else xPos -= AISLE_GAP_X / 2;

                        // è¨ˆç®— Z
                        let zPos = ((TOTAL_ROWS / 2) - 0.5 - r) * SPACING_Z;
                        if (r >= ROWS_BOTTOM) zPos -= AISLE_GAP_Z / 2;
                        else zPos += AISLE_GAP_Z / 2;

                        columnPositions.push({x: xPos, z: zPos});
                    }

                    // è›‡è¡Œåè½‰
                    if (!isGoingUp) columnPositions.reverse();

                    // ä¾åºæ”¾ç½®æ¡Œå­
                    columnPositions.forEach(pos => {
                        
                        // ğŸš¨ ç‰¹æ®Šé‚è¼¯ï¼šä½ç½® 222 (åœ¨ç¬¬ä¸€è±¡é™æŸè™•) è¦ç•™ç©º
                        // æˆ‘å€‘ç”¨ positionCounter ä¾†è¿½è¹¤ã€Œç‰©ç†ä½ç½®ã€
                        // ç”¨ tableCounter ä¾†è¿½è¹¤ã€Œæ¡Œè™Ÿã€
                        
                        if (positionCounter === 222) {
                            // ä»€éº¼éƒ½ä¸åšï¼Œè·³éç”Ÿæˆï¼Œæ¡Œè™Ÿä¹Ÿä¸åŠ 
                            console.log("Skipping position 222 (Empty Space)");
                        } else {
                            // æ­£å¸¸ç”Ÿæˆæ¡Œå­
                            createFancyTableGroup(tableCounter, pos.x, pos.z, font);
                            tableCounter++; // åªæœ‰ç”Ÿæˆäº†æ¡Œå­ï¼Œæ¡Œè™Ÿæ‰+1
                        }

                        positionCounter++; // ç‰©ç†ä½ç½®æ°¸é +1
                    });
                }
                
                console.log(`Total tables generated: ${tableCounter - 1}`); // æ‡‰è©²æ˜¯ 237
            });
        }

        // --- è¦–è¦ºå‡ç´šï¼šé«˜ç´šæ¡Œæ¤…æ¨¡å‹ ---
        function createFancyTableGroup(id, x, z, font) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            // 1. ä¸»æ¡Œå¸ƒ (ç´…è‰²çµ²çµ¨è³ªæ„Ÿ)
            const tableGeo = new THREE.CylinderGeometry(TABLE_RADIUS, TABLE_RADIUS, 0.2, 64);
            const tableMat = new THREE.MeshStandardMaterial({ 
                color: 0xcd5c5c, // æ·±ç´…è‰²æ¡Œå¸ƒ (æ”¹æˆindian red)
                roughness: 0.8,
                metalness: 0.1
            });
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.y = 0.8; // æ¡Œè…³é«˜åº¦
            table.castShadow = true;
            table.receiveShadow = true;
            group.add(table);

            // 2. ç»ç’ƒè½‰ç›¤ (Inner Lazy Susan)
            const susanGeo = new THREE.CylinderGeometry(INNER_TABLE_RADIUS, INNER_TABLE_RADIUS, 0.05, 32);
            const susanMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.4,
                roughness: 0.1,
                transmission: 0.8 // ç»ç’ƒè³ªæ„Ÿ
            });
            const susan = new THREE.Mesh(susanGeo, susanMat);
            susan.position.y = 0.95;
            group.add(susan);

            // 3. æ‡¸æµ®ç§‘æŠ€æ¡Œè™Ÿ
            const textGeo = new THREE.TextGeometry(String(id), {
                font: font, size: 0.8, height: 0.1
            });
            textGeo.center();
            const textMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const textMesh = new THREE.Mesh(textGeo, textMat);
            textMesh.position.y = 2.5;
            textMesh.rotation.x = -Math.PI / 2; // èººå¹³æœä¸Š
            group.add(textMesh);

            // 4. ç”Ÿæˆ 10 å¼µæœ‰é èƒŒçš„æ¤…å­
            const seats = [];
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                const dist = 2.2;
                
                const seatGroup = new THREE.Group();
                const sx = Math.cos(angle) * dist;
                const sz = Math.sin(angle) * dist;
                seatGroup.position.set(sx, 0, sz);
                seatGroup.rotation.y = -angle + Math.PI/2; // é¢å‘æ¡Œå­

                // æ¤…å¢Š
                const cushionGeo = new THREE.BoxGeometry(0.6, 0.1, 0.6);
                const cushionMat = new THREE.MeshStandardMaterial({ color: 0xcccccc }); // ç°è‰²æ¤…å¢Š
                const cushion = new THREE.Mesh(cushionGeo, cushionMat);
                cushion.position.y = 0.5;
                cushion.castShadow = true;
                seatGroup.add(cushion);

                // æ¤…èƒŒ
                const backGeo = new THREE.BoxGeometry(0.6, 0.6, 0.05);
                const back = new THREE.Mesh(backGeo, cushionMat);
                back.position.set(0, 0.8, 0.28); // ç¨å¾®å¾€å¾Œ
                back.castShadow = true;
                seatGroup.add(back);

                // ç¶å®šè³‡æ–™
                // æˆ‘å€‘ç¶å®šåœ¨ seatGroup ä¸Šï¼Œä¹‹å¾Œé«˜äº®æ™‚æ”¹è®Š cushion çš„é¡è‰²
                seatGroup.userData = { 
                    parentId: id, 
                    seatNum: i + 1, 
                    cushionMesh: cushion, // å­˜èµ·ä¾†æ–¹ä¾¿æ”¹è‰²
                    backMesh: back
                };

                group.add(seatGroup);
                seats.push(seatGroup);
            }

            // å„²å­˜åƒç…§
            tableGroups[String(id)] = {
                group: group,
                seats: seats,
                text: textMesh,
                tableMesh: table
            };

            scene.add(group);
        }

        async function queryDeskLocation() {
            const input = document.getElementById('employeeName');
            const status = document.getElementById('status-msg');
            const loader = document.getElementById('loader');
            const resultArea = document.getElementById('result-area');
            
            const name = input.value.trim();
            if(!name) return;

            status.innerText = "SEARCHING DATABASE...";
            loader.style.width = "100%";
            resetHighlights();
            resultArea.style.display = 'none';

            try {
                const res = await fetch(`${GAS_API_URL}?name=${encodeURIComponent(name)}`);
                const data = await res.json();

                loader.style.width = "0%";

                if(!data.success || data.count === 0) {
                    status.innerText = "NO RECORD FOUND / æŸ¥ç„¡æ­¤äºº";
                    return;
                }

                status.innerText = `RESULT FOUND: ${data.count}`;
                resultArea.style.display = 'block';
                resultArea.innerHTML = '';

                data.data.forEach((emp, idx) => {
                    const deskStr = String(emp.Desk).trim(); 
                    const parts = deskStr.split('-'); 

                    let bigTableId = parts[0];
                    let seatNum = parts.length > 1 ? parseInt(parts[1]) : null;

                    const card = document.createElement('div');
                    card.className = 'result-card';
                    card.innerHTML = `
                        <div class="info-row"><span>NAME</span><span class="info-val">${emp.Name}</span></div>
                        <div class="info-row"><span>DEPT</span><span class="info-val">${emp.Dept}</span></div>
                        <div style="margin-top:10px; border-top:1px solid #444; padding-top:10px; text-align:right;">
                            <div class="big-seat-num">${deskStr}</div>
                        </div>
                    `;
                    resultArea.appendChild(card);

                    const target = tableGroups[bigTableId];
                    if(target) {
                        // é«˜äº®æ¡Œè™Ÿ
                        target.text.material.color.setHex(0xffaa00);
                        target.text.scale.set(2, 2, 2);
                        
                        // é«˜äº®æ¡Œå¸ƒ (è®Šæˆäº®ä¸€é»çš„ç´…è‰²)
                        target.tableMesh.material.emissive.setHex(0x330000);

                        // é«˜äº®æ¤…å­
                        if(seatNum && seatNum >= 1 && seatNum <= 10) {
                            const seatObj = target.seats[seatNum - 1];
                            if(seatObj) {
                                // æ¤…å­è®Šäº®ç²‰ç´…
                                seatObj.userData.cushionMesh.material.color.setHex(0xff0055);
                                seatObj.userData.cushionMesh.material.emissive.setHex(0x440022);
                                seatObj.userData.backMesh.material.color.setHex(0xff0055);
                            }
                        } else {
                            // æ•´æ¡Œæ¤…å­è®Šè‰²
                            target.seats.forEach(s => {
                                s.userData.cushionMesh.material.color.setHex(0xffaa00);
                            });
                        }

                        if(idx === 0) flyTo(target.group.position);
                    }
                });

            } catch(e) {
                console.error(e);
                status.innerText = "CONNECTION ERROR";
                loader.style.width = "0%";
            }
        }

        function resetHighlights() {
            for(let id in tableGroups) {
                const t = tableGroups[id];
                // æ¢å¾©æ–‡å­—
                t.text.material.color.setHex(0xffffff);
                t.text.scale.set(1, 1, 1);
                // æ¢å¾©æ¡Œå¸ƒç„¡è‡ªç™¼å…‰
                t.tableMesh.material.emissive.setHex(0x000000);
                
                // æ¢å¾©æ¤…å­ç°è‰²
                t.seats.forEach(s => {
                    s.userData.cushionMesh.material.color.setHex(0xcccccc);
                    s.userData.cushionMesh.material.emissive.setHex(0x000000);
                    s.userData.backMesh.material.color.setHex(0xcccccc);
                });
            }
        }

        function flyTo(pos) {
            const targetPos = { x: pos.x, y: 30, z: pos.z + 15 }; 
            
            new TWEEN.Tween(camera.position).to(targetPos, 1200)
                .easing(TWEEN.Easing.Cubic.Out).start();
                
            new TWEEN.Tween(controls.target).to({x: pos.x, y: 0, z: pos.z}, 1200)
                .easing(TWEEN.Easing.Cubic.Out).start();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
